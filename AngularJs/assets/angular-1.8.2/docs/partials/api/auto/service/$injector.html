<a href='https://github.com/angular/angular.js/edit/v1.8.x/src/auto/injector.js?message=docs($injector)%3A%20describe%20your%20change...#L130' class='improve-docs btn btn-primary'><i class="glyphicon glyphicon-edit">&nbsp;</i>Improve this Doc</a>



<a href='https://github.com/angular/angular.js/tree/v1.8.2/src/auto/injector.js#L130' class='view-source pull-right btn btn-primary'>
  <i class="glyphicon glyphicon-zoom-in">&nbsp;</i>View Source
</a>


<header class="api-profile-header">
  <h1 class="api-profile-header-heading">$injector</h1>
  <ol class="api-profile-header-structure naked-list step-list">
    
  

    <li>
      - service in module <a href="api/auto">auto</a>
    </li>
  </ol>
</header>





<div class="api-profile-description">
  <h2 id="overview">Overview</h2>
  <p><code>$injector</code> is used to retrieve object instances as defined by
<a href="api/auto/service/$provide">provider</a>, instantiate types, invoke methods,
and load modules.</p>
<p>The following always holds true:</p>
<pre><code class="lang-js">var $injector = angular.injector();
expect($injector.get(&#39;$injector&#39;)).toBe($injector);
expect($injector.invoke(function($injector) {
  return $injector;
})).toBe($injector);
</code></pre>
<h2 id="injection-function-annotation">Injection Function Annotation</h2>
<p>JavaScript does not have annotations, and annotations are needed for dependency injection. The
following are all valid ways of annotating function with injection arguments and are equivalent.</p>
<pre><code class="lang-js">// inferred (only works if code not minified/obfuscated)
$injector.invoke(function(serviceA){});

// annotated
function explicit(serviceA) {};
explicit.$inject = [&#39;serviceA&#39;];
$injector.invoke(explicit);

// inline
$injector.invoke([&#39;serviceA&#39;, function(serviceA){}]);
</code></pre>
<h3 id="inference">Inference</h3>
<p>In JavaScript calling <code>toString()</code> on a function returns the function definition. The definition
can then be parsed and the function arguments can be extracted. This method of discovering
annotations is disallowed when the injector is in strict mode.
<em>NOTE:</em> This does not work with minification, and obfuscation tools since these tools change the
argument names.</p>
<h3 id="-inject-annotation"><code>$inject</code> Annotation</h3>
<p>By adding an <code>$inject</code> property onto a function the injection parameters can be specified.</p>
<h3 id="inline">Inline</h3>
<p>As an array of injection names, where the last item in the array is the function to call.</p>

</div>




<div>
  

  

  

  
<h2 id="$injector-methods">Methods</h2>
<ul class="methods">
  <li>
    <h3 id="get"><p><code>get(name, [caller]);</code></p>

</h3>
    <div><p>Return an instance of the service.</p>
</div>

    

    
    <h4>Parameters</h4>
    
<table class="variables-matrix input-arguments">
  <thead>
    <tr>
      <th>Param</th>
      <th>Type</th>
      <th>Details</th>
    </tr>
  </thead>
  <tbody>
    
    <tr>
      <td>
        name
        
        
      </td>
      <td>
        <a href="" class="label type-hint type-hint-string">string</a>
      </td>
      <td>
        <p>The name of the instance to retrieve.</p>

        
      </td>
    </tr>
    
    <tr>
      <td>
        caller
        
        <div><em>(optional)</em></div>
      </td>
      <td>
        <a href="" class="label type-hint type-hint-string">string</a>
      </td>
      <td>
        <p>An optional string to provide the origin of the function call for error messages.</p>

        
      </td>
    </tr>
    
  </tbody>
</table>

    

    

    
    <h4>Returns</h4>
    <table class="variables-matrix return-arguments">
  <tr>
    <td><a href="" class="label type-hint type-hint-object">*</a></td>
    <td><p>The instance.</p>
</td>
  </tr>
</table>
    </li>
  
  <li>
    <h3 id="invoke"><p><code>invoke(fn, [self], [locals]);</code></p>

</h3>
    <div><p>Invoke the method and supply the method arguments from the <code>$injector</code>.</p>
</div>

    

    
    <h4>Parameters</h4>
    
<table class="variables-matrix input-arguments">
  <thead>
    <tr>
      <th>Param</th>
      <th>Type</th>
      <th>Details</th>
    </tr>
  </thead>
  <tbody>
    
    <tr>
      <td>
        fn
        
        
      </td>
      <td>
        <a href="" class="label type-hint type-hint-function">function()</a><a href="" class="label type-hint type-hint-array">Array.&lt;(string|function())&gt;</a>
      </td>
      <td>
        <p>The injectable function to invoke. Function parameters are
  injected according to the <a href="guide/di">$inject Annotation</a> rules.</p>

        
      </td>
    </tr>
    
    <tr>
      <td>
        self
        
        <div><em>(optional)</em></div>
      </td>
      <td>
        <a href="" class="label type-hint type-hint-object">Object</a>
      </td>
      <td>
        <p>The <code>this</code> for the invoked method.</p>

        
      </td>
    </tr>
    
    <tr>
      <td>
        locals
        
        <div><em>(optional)</em></div>
      </td>
      <td>
        <a href="" class="label type-hint type-hint-object">Object</a>
      </td>
      <td>
        <p>Optional object. If preset then any argument names are read from this
                        object first, before the <code>$injector</code> is consulted.</p>

        
      </td>
    </tr>
    
  </tbody>
</table>

    

    

    
    <h4>Returns</h4>
    <table class="variables-matrix return-arguments">
  <tr>
    <td><a href="" class="label type-hint type-hint-object">*</a></td>
    <td><p>the value returned by the invoked <code>fn</code> function.</p>
</td>
  </tr>
</table>
    </li>
  
  <li>
    <h3 id="has"><p><code>has(name);</code></p>

</h3>
    <div><p>Allows the user to query if the particular service exists.</p>
</div>

    

    
    <h4>Parameters</h4>
    
<table class="variables-matrix input-arguments">
  <thead>
    <tr>
      <th>Param</th>
      <th>Type</th>
      <th>Details</th>
    </tr>
  </thead>
  <tbody>
    
    <tr>
      <td>
        name
        
        
      </td>
      <td>
        <a href="" class="label type-hint type-hint-string">string</a>
      </td>
      <td>
        <p>Name of the service to query.</p>

        
      </td>
    </tr>
    
  </tbody>
</table>

    

    

    
    <h4>Returns</h4>
    <table class="variables-matrix return-arguments">
  <tr>
    <td><a href="" class="label type-hint type-hint-boolean">boolean</a></td>
    <td><p><code>true</code> if injector has given service.</p>
</td>
  </tr>
</table>
    </li>
  
  <li>
    <h3 id="instantiate"><p><code>instantiate(Type, [locals]);</code></p>

</h3>
    <div><p>Create a new instance of JS type. The method takes a constructor function, invokes the new
operator, and supplies all of the arguments to the constructor function as specified by the
constructor annotation.</p>
</div>

    

    
    <h4>Parameters</h4>
    
<table class="variables-matrix input-arguments">
  <thead>
    <tr>
      <th>Param</th>
      <th>Type</th>
      <th>Details</th>
    </tr>
  </thead>
  <tbody>
    
    <tr>
      <td>
        Type
        
        
      </td>
      <td>
        <a href="" class="label type-hint type-hint-function">Function</a>
      </td>
      <td>
        <p>Annotated constructor function.</p>

        
      </td>
    </tr>
    
    <tr>
      <td>
        locals
        
        <div><em>(optional)</em></div>
      </td>
      <td>
        <a href="" class="label type-hint type-hint-object">Object</a>
      </td>
      <td>
        <p>Optional object. If preset then any argument names are read from this
object first, before the <code>$injector</code> is consulted.</p>

        
      </td>
    </tr>
    
  </tbody>
</table>

    

    

    
    <h4>Returns</h4>
    <table class="variables-matrix return-arguments">
  <tr>
    <td><a href="" class="label type-hint type-hint-object">Object</a></td>
    <td><p>new instance of <code>Type</code>.</p>
</td>
  </tr>
</table>
    </li>
  
  <li>
    <h3 id="annotate"><p><code>annotate(fn, [strictDi]);</code></p>

</h3>
    <div><p>Returns an array of service names which the function is requesting for injection. This API is
used by the injector to determine which services need to be injected into the function when the
function is invoked. There are three ways in which the function can be annotated with the needed
dependencies.</p>
<h4 id="argument-names">Argument names</h4>
<p>The simplest form is to extract the dependencies from the arguments of the function. This is done
by converting the function into a string using <code>toString()</code> method and extracting the argument
names.</p>
<pre><code class="lang-js">// Given
function MyController($scope, $route) {
  // ...
}

// Then
expect(injector.annotate(MyController)).toEqual([&#39;$scope&#39;, &#39;$route&#39;]);
</code></pre>
<p>You can disallow this method by using strict injection mode.</p>
<p>This method does not work with code minification / obfuscation. For this reason the following
annotation strategies are supported.</p>
<h4 id="the-inject-property">The <code>$inject</code> property</h4>
<p>If a function has an <code>$inject</code> property and its value is an array of strings, then the strings
represent names of services to be injected into the function.</p>
<pre><code class="lang-js">// Given
var MyController = function(obfuscatedScope, obfuscatedRoute) {
  // ...
}
// Define function dependencies
MyController[&#39;$inject&#39;] = [&#39;$scope&#39;, &#39;$route&#39;];

// Then
expect(injector.annotate(MyController)).toEqual([&#39;$scope&#39;, &#39;$route&#39;]);
</code></pre>
<h4 id="the-array-notation">The array notation</h4>
<p>It is often desirable to inline Injected functions and that&#39;s when setting the <code>$inject</code> property
is very inconvenient. In these situations using the array notation to specify the dependencies in
a way that survives minification is a better choice:</p>
<pre><code class="lang-js">// We wish to write this (not minification / obfuscation safe)
injector.invoke(function($compile, $rootScope) {
  // ...
});

// We are forced to write break inlining
var tmpFn = function(obfuscatedCompile, obfuscatedRootScope) {
  // ...
};
tmpFn.$inject = [&#39;$compile&#39;, &#39;$rootScope&#39;];
injector.invoke(tmpFn);

// To better support inline function the inline annotation is supported
injector.invoke([&#39;$compile&#39;, &#39;$rootScope&#39;, function(obfCompile, obfRootScope) {
  // ...
}]);

// Therefore
expect(injector.annotate(
   [&#39;$compile&#39;, &#39;$rootScope&#39;, function(obfus_$compile, obfus_$rootScope) {}])
 ).toEqual([&#39;$compile&#39;, &#39;$rootScope&#39;]);
</code></pre>
</div>

    

    
    <h4>Parameters</h4>
    
<table class="variables-matrix input-arguments">
  <thead>
    <tr>
      <th>Param</th>
      <th>Type</th>
      <th>Details</th>
    </tr>
  </thead>
  <tbody>
    
    <tr>
      <td>
        fn
        
        
      </td>
      <td>
        <a href="" class="label type-hint type-hint-function">function()</a><a href="" class="label type-hint type-hint-array">Array.&lt;(string|function())&gt;</a>
      </td>
      <td>
        <p>Function for which dependent service names need to
be retrieved as described above.</p>

        
      </td>
    </tr>
    
    <tr>
      <td>
        strictDi
        
        <div><em>(optional)</em></div>
      </td>
      <td>
        <a href="" class="label type-hint type-hint-boolean">boolean</a>
      </td>
      <td>
        <p>Disallow argument name annotation inference.</p>

        <p><em>(default: false)</em></p>
      </td>
    </tr>
    
  </tbody>
</table>

    

    

    
    <h4>Returns</h4>
    <table class="variables-matrix return-arguments">
  <tr>
    <td><a href="" class="label type-hint type-hint-array">Array.&lt;string&gt;</a></td>
    <td><p>The names of the services which the function requires.</p>
</td>
  </tr>
</table>
    </li>
  
  <li>
    <h3 id="loadNewModules"><p><code>loadNewModules([mods]);</code></p>

</h3>
    <div><p><strong>This is a dangerous API, which you use at your own risk!</strong></p>
<p>Add the specified modules to the current injector.</p>
<p>This method will add each of the injectables to the injector and execute all of the config and run
blocks for each module passed to the method.</p>
<p>If a module has already been loaded into the injector then it will not be loaded again.</p>
<ul>
<li>The application developer is responsible for loading the code containing the modules; and for
ensuring that lazy scripts are not downloaded and executed more often that desired.</li>
<li>Previously compiled HTML will not be affected by newly loaded directives, filters and components.</li>
<li>Modules cannot be unloaded.</li>
</ul>
<p>You can use <a href="api/auto/service/$injector#modules"><code>$injector.modules</code></a> to check whether a module has been loaded
into the injector, which may indicate whether the script has been executed already.</p>
</div>

    

    
    <h4>Parameters</h4>
    
<table class="variables-matrix input-arguments">
  <thead>
    <tr>
      <th>Param</th>
      <th>Type</th>
      <th>Details</th>
    </tr>
  </thead>
  <tbody>
    
    <tr>
      <td>
        mods
        
        <div><em>(optional)</em></div>
      </td>
      <td>
        <a href="" class="label type-hint type-hint-array">Array&lt;String|Function|Array&gt;=</a>
      </td>
      <td>
        <p>an array of modules to load into the application.
    Each item in the array should be the name of a predefined module or a (DI annotated)
    function that will be invoked by the injector as a <code>config</code> block.
    See: <a href="api/ng/function/angular.module">modules</a></p>

        
      </td>
    </tr>
    
  </tbody>
</table>

    

    

    
    <h4 id="$injector.loadNewModules-examples">Example</h4><p>Here is an example of loading a bundle of modules, with a utility method called <code>getScript</code>:</p>
<pre><code class="lang-javascript">app.factory(&#39;loadModule&#39;, function($injector) {
  return function loadModule(moduleName, bundleUrl) {
    return getScript(bundleUrl).then(function() { $injector.loadNewModules([moduleName]); });
  };
})
</code></pre>
</li>
  </ul>
  
  
<h2 id="$injector-properties">Properties</h2>
<ul class="properties">
  <li>
    <h3 id="modules"><code>modules</code></h3>
    <table class="variables-matrix return-arguments">
  <tr>
    <td></td>
    <td><p>A hash containing all the modules that have been loaded into the
$injector.</p>
<p>You can use this property to find out information about a module via the
<a href="api/ng/type/angular.Module#info"><code>myModule.info(...)</code></a> method.</p>
<p>For example:</p>
<pre><code>var info = $injector.modules[&#39;ngAnimate&#39;].info();
</code></pre>
<p><strong>Do not use this property to attempt to modify the modules after the application
has been bootstrapped.</strong></p>
</td>
  </tr>
</table>
    
  </li>
  </ul>



  
</div>


